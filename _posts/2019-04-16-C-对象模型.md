---
title: C++ 对象模型
date: 2019-04-16 10:33:51
tags:
---

# 构造函数语意学

## 默认构造函数的构造操作

- 编译器的需要
- 程序的需要
- trivial constructor
- nontrivial constructor

## 拷贝构造函数的构造操作

- Memberwise Initialization
- Bitwise Copy Semantics

## 程序转换语意学

## 成员初始化列表

# Data 语意学

菱形继承各类的大小

## Data Member 的绑定

- 成员函数体内的名字解析直到类的声明都出现了才开始
- 成员函数的参数列表不符合上一条规则，名字解析从参数第一次出现开始
  
## Data Member 的布局


## Data Member 的存取

- Static Data Members
- Nonstatic Data Members
  - 欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始位置加上data member的偏移位置。

## 继承与 Data Member

- 不使用继承
- 不含多态的继承
  - 在使用继承时，派生类中的基类子对象具有完整原样性，派生类部分的成员不直接使用基类子对象的填充部分
- 含多态的继承
  - vptr
- 多重继承
  - 多重继承的问题主要发生于派生类和其第二或后继基类object之间的转换
- 虚继承    
  - 不变区域
  - 共享区域

## 指向 Data Members 的指针

- float Point::*p = &Point::x;
    - float 指针 p 指向 Point 对象 x
    - &Point::x 得到 x 在 class object 中的偏移位置

# Function 语意学

## Member 的各种调用方式

- Nonstatic Member Functions
  - 编译器内部会将“member 函数实例”转换为对等的“nonmember 函数实例”
  - 含有 this 指针
- Static Member Functions
  - static member function 没有 this 指针，因此差不多等同于 nonmember function
- Virtual Member Functions

## Virtual Member Functions 

- 单继承中的虚函数
  - (*ptr->vptr[1])(ptr)
- 多继承中的虚函数
  - 在多重继承中支持virtual functions，其复杂度围绕在第二个及后继的base classes身上，以及“必须在执行期调整this指针”这一点
  - 在多重继承下，一个derived class内含n-1个"额外"的virtual tables，n表示其上一层base classes的个数（因此，单一继承将不会有额外的virtual tables）。
- 虚继承下的虚函数

## 指向 Member Function 的指针

float (Point::*pf)() = &Point::x;

- 支持指向 Virtual Member Functions 的指针
- 多重继承下，指向 Member Functions 的指针

# 构造、析构、拷贝语意学

## 无继承情况下的对象构造

- C struct 的 Point 声明
- 抽象数据类型
- 包含虚函数的 Point 声明

## 继承体系下的对象构造

## 对象拷贝语意学

# 执行期语意学

##　静态对象的构造和析构


# 相关问题

C++ 函数返回值可以是引用吗？可以，但是不能是函数的局部变量，因为局部变量在函数结束后会被销毁。
类的空指针可以调用一个空方法或者虚函数吗？可以调用普通函数，而不能调用虚函数。因为调用虚函数会使用vptr，而空指针不存在对象。
